# FAQ

```{=html}
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  },
  svg: {
    fontCache: 'global'
  }
};
</script>
```

## HTML

* [Relative widths tables: `table-layout: fixed` vs `auto`.](https://github.com/vincentarelbundock/tinytable/issues/305)

## LaTeX

### Preamble

`tinytable` uses the `tabularray` package from your LaTeX distribution to draw tables. `tabularray`, in turn, provides special `tblr`, `talltblr`, and `longtblr` environments to display tabular data.

When rendering a document from Quarto or Rmarkdown directly to PDF, `tinytable` will populate the LaTeX preamble automatically with all the required packages (except when code chunks are cached). For standalone LaTeX documents, these commands should be inserted in the preamble manually:

```latex
\usepackage{tabularray}
\usepackage{float}
\usepackage{graphicx}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\UseTblrLibrary{booktabs}
\UseTblrLibrary{siunitx}
\newcommand{\tinytableTabularrayUnderline}[1]{\underline{#1}}
\newcommand{\tinytableTabularrayStrikeout}[1]{\sout{#1}}
\NewTableCommand{\tinytableDefineColor}[3]{\definecolor{#1}{#2}{#3}}
```

### `setspace`

Some users have encountered unexpected spacing behavior when generating tables that are *not* wrapped in a `\begin{table}` environment (ex: `multipage` or raw `tblr`).

One issue stems from the fact that the `\begin{table}` environment resets any spacing commands in the preamble or body by default, such as:

```tex
\usepackage{setspace}
\doublespacing
```

This means that when using `theme_tt("multipage")` ---which does not wrap the table in a `table` environment--- the spacing is *not* reset, and tables are double spaced. This is not a bug, since double-spacing is in fact what the user requested. Nevertheless, the behavior can seem surprising for those used to the automagical `table` environment spacing reset.

One workaround is to add the following to the document preamble when using multipage/longtblr:

```tex
\usepackage{etoolbox}
\AtBeginEnvironment{longtblr}{\begin{singlespacing}}
\AtEndEnvironment{longtblr}{\end{singlespacing}}
```

Example Quarto doc:

  
````md
---
title: longtblr and setspacing
format:
  pdf:
    include-in-header:
      - text: |
         % Tinytable preamble
         \usepackage{tabularray}
         \usepackage{float}
         \usepackage{graphicx}
         \usepackage{codehigh}
         \usepackage[normalem]{ulem}
         \UseTblrLibrary{booktabs}
         \UseTblrLibrary{siunitx}
         \newcommand{\tinytableTabularrayUnderline}[1]{\underline
         {#1}}
         \newcommand{\tinytableTabularrayStrikeout}[1]{\sout{#1}}
         \NewTableCommand{\tinytableDefineColor}[3]{\definecolor{
         #1}{#2}{#3}}
         % Spacing Commands
         \usepackage{setspace}
         \doublespacing
         % Fix Spacing in longtblr
         \usepackage{etoolbox}
         \AtBeginEnvironment{longtblr}{\begin{singlespacing}}
         \AtEndEnvironment{longtblr}{\end{singlespacing}}
---

```{=latex}
\begin{longtblr}[         %% tabularray outer open
]                     %% tabularray outer close
{                     %% tabularray inner open
colspec={Q[]Q[]Q[]Q[]},
}                     %% tabularray inner close
\toprule
foo & bar & baz \\
foo & bar & baz \\
foo & bar & baz \\
\bottomrule
\end{longtblr}
```
````

### Multi-line cells and complex markdown with `minipage`

In some contexts, users may want to include multi-line cells or complex Markdown formatting in their tables. The key distinction here is that one-line Markdown can often be rendered directly with `markdown = TRUE` in `tinytable`. However, when you have multi-line Markdown (e.g., bullet points, lists, or long text), you need to wrap it in a LaTeX `\minipage` environment so that it renders correctly in PDF output. To do this, we write two simple helper functions: `latexify` and `minipagify`.


Below is the complete code:

```{r}
library(tinytable)
library(litedown)

dat <- data.frame(
  A = c("Blah *blah* blah", "- Thing 1\n- Thing 2"),
  B = c("6%", "$5.29")
)

tab <- tt(dat, width = c(0.3, 0.2)) |>
  style_tt(j = 2, align = "c") |>
  format_tt(j = 2, markdown = TRUE) |>
  format_tt(i = 1, j = 1, markdown = TRUE)

# render markdown code in each cell individually
latexify <- \(x) sapply(x, litedown::mark, "latex")

# wrap multi-line cell content in minipage
minipagify <- \(x) paste("\\minipage{\\textwidth}", latexify(x), "\\endminipage")

# only make the change for LaTeX output
if (identical(knitr::to_pandoc(), "latex")) {
  x <- format_tt(x, i = i, j = j, fn = minipagify)
}

tab
```

### Global styles

`tabularray` allows very powerful styling and themeing options. See [the reference manual](https://ctan.org/pkg/tabularray) for more information.

For example, you can change the size of footnotes in all tables of a document with:

````{verbatim}
---
format: 
    pdf:
        keep-tex: true
        header-includes: |
            \SetTblrStyle{foot}{font=\LARGE}
---

```{r}
library(tinytable)
library(magrittr)
tt(head(iris), notes = "Blah blah")
```
````


### Beamer

Due to [a bug in the upstream package `rmarkdown`](https://github.com/rstudio/rmarkdown/issues/2478), Quarto or Rmarkdown presentations compiled to Beamer cannot include adequate package loading commands in the preamble automatically. This bug prevents `tinytable::usepackage_latex()` from modifying the preamble. Here's a workaround.

Save this LaTeX code as `preamble.tex`:

```latex
\RequirePackage{tabularray}
\RequirePackage{booktabs}
\RequirePackage{float}
\usepackage[normalem]{ulem}
\usepackage{graphicx}
\UseTblrLibrary{booktabs}
\UseTblrLibrary{siunitx}
\NewTableCommand{\tinytableDefineColor}[3]{\definecolor{#1}{#2}{#3}}
\newcommand{\tinytableTabularrayUnderline}[1]{\underline{#1}}
\newcommand{\tinytableTabularrayStrikeout}[1]{\sout{#1}}
```

Then, load `preamble.tex` in your YAML header:

````yaml
---
output: 
  beamer_presentation:
    includes:
      in_header: preamble.tex
---
````

With these changes, the table should appear with colors as expected.


## Typst

### Quarto

By default `tinytable` uses Quarto's own figure handling to set captions and figure blocks. This allows cross-references to work. For this to work well, users should specify _both_ the table label and the table caption explicitly using chunk options. Note that the label must imperatively start with `tbl-`:

```r
#| label: tbl-example
#| tbl-cap: This is an example table
library(tinytable)
tt(head(iris))
```

Alternatively, users can disable Quarto table handling and rely on internal `tinytable` options instead.

```r
options(tinytable_quarto_figure = FALSE)
```

Doing this will prevent styles to bleed over from one table to the next.

### Multi-page long tables

The Typst tables created by `tinytable` are automatically broken across pages with repeated headers. However, in Quarto documents, the Quarto software wraps tables in an non-breakable `#figure` environment. This can break the display of long tables. One solution is to use a raw Typst code block to set Figures to be breakable:

````{verbatim}
---
format: typst
---

```{=typst}
#show figure: set block(breakable: true)
```

```{r}
#| tbl-cap: "blah blah blah"
#| label: tbl-blah
library(tinytable)
tt(head(iris, 50))
```
````


## Markdown

### `style_tt()` does not apply to row headers

This is an important limitation, but it is difficult to get around. See this issue for discussion: https://github.com/vincentarelbundock/tinytable/issues/125

Users can use markdown styling directly in `group_tt()` to circumvent this. This is documented in the tutorial.

### `rowspan` and `colspan`

These arguments are already implemented in the form of "pseudo-spans", meaning that we flush the content of adjacent cells, but do not modify the row or column borders. This is probably adequate for most needs. 

One alternative would be to remove line segments in finalize_grid(). I tried this but it is tricky and the results were brittle, so I rolled it back. I'm open to considering a PR if someone wants to contribute code, but please discuss the feature design in an issue with me before working on this.



## Word (`.docx`)

Word document documents are created in two steps:

1. Generates a markdown table.
2. Call the external [Pandoc software](https://pandoc.org/) to convert the markdown table to a Word document.

This workflow limits the range of styling options available in Word. Indeed, many arguments in the `style_tt()` function do not have formal markdown notation to represent them, and are thus not available. For example, while `italic`, `bold`, and `strikeout`, are supported, `color` and `background` are not.

Note that other `tinytable` functions such as `group_tt()` and `format_tt()` and `plot_tt()` should work as expected in Word.

Users who want full styling capabilities in Word can save tables as image files and insert them in their documents. Here is an example Quarto notebook illustrating this workflow.

````{verbatim}
---
format: docx
---

```{r}
#| out-width: "50%"
library(tinytable)

options(tinytable_save_overwrite = TRUE)

tt(mtcars[1:10, 1:5]) |>
  style_tt(j = 2:3, background = "black", color = "white") |>
  save_tt("table_01.png")

knitr::include_graphics("table_01.png")
```
````


